package de.mslab.ciphers;

import de.mslab.core.ByteArray;

/**
 * Abstract base class for the ARIA block cipher, 
 * the South-Korean equivalent to the AES standardized 2003/2004. 
 * 
 */
public class ARIA extends AbstractRoundBasedBlockCipher {

	public static final int NUM_COLUMNS_IN_STATE = 4;
	public static final int NUM_ROWS_IN_STATE = 4;
	public static final int NUM_BYTES_IN_STATE = NUM_COLUMNS_IN_STATE * NUM_ROWS_IN_STATE;
	
	public static final long[] C1 = { 0x517cc1b727220a94L, 0xfe13abe8fa9a6ee0L };
	public static final long[] C2 = { 0x6db14acc9e21c820L, 0xff28b1d5ef5de2b0L };
	public static final long[] C3 = { 0xdb92371d2126e970L, 0x0324977504e8c90eL };
	
	public static long[] keyExpansionConstant1, keyExpansionConstant2, keyExpansionConstant3;
	
	protected static final short[] INVERSE_SBOX1 = {
		0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 
		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 
		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 
		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 
		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 
		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 
		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 
		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 
		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 
		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 
		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 
		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 
		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
	};
	protected static final short[] INVERSE_SBOX2 = {
		0x30, 0x68, 0x99, 0x1b, 0x87, 0xb9, 0x21, 0x78, 0x50, 0x39, 0xdb, 0xe1, 0x72, 0x09, 0x62, 0x3c, 
		0x3e, 0x7e, 0x5e, 0x8e, 0xf1, 0xa0, 0xcc, 0xa3, 0x2a, 0x1d, 0xfb, 0xb6, 0xd6, 0x20, 0xc4, 0x8d, 
		0x81, 0x65, 0xf5, 0x89, 0xcb, 0x9d, 0x77, 0xc6, 0x57, 0x43, 0x56, 0x17, 0xd4, 0x40, 0x1a, 0x4d, 
		0xc0, 0x63, 0x6c, 0xe3, 0xb7, 0xc8, 0x64, 0x6a, 0x53, 0xaa, 0x38, 0x98, 0x0c, 0xf4, 0x9b, 0xed, 
		0x7f, 0x22, 0x76, 0xaf, 0xdd, 0x3a, 0x0b, 0x58, 0x67, 0x88, 0x06, 0xc3, 0x35, 0x0d, 0x01, 0x8b, 
		0x8c, 0xc2, 0xe6, 0x5f, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1e, 0xe5, 0xe2, 0x54, 0xd8, 0x10, 0xce, 
		0x7a, 0xe8, 0x08, 0x2c, 0x12, 0x97, 0x32, 0xab, 0xb4, 0x27, 0x0a, 0x23, 0xdf, 0xef, 0xca, 0xd9, 
		0xb8, 0xfa, 0xdc, 0x31, 0x6b, 0xd1, 0xad, 0x19, 0x49, 0xbd, 0x51, 0x96, 0xee, 0xe4, 0xa8, 0x41, 
		0xda, 0xff, 0xcd, 0x55, 0x86, 0x36, 0xbe, 0x61, 0x52, 0xf8, 0xbb, 0x0e, 0x82, 0x48, 0x69, 0x9a, 
		0xe0, 0x47, 0x9e, 0x5c, 0x04, 0x4b, 0x34, 0x15, 0x79, 0x26, 0xa7, 0xde, 0x29, 0xae, 0x92, 0xd7, 
		0x84, 0xe9, 0xd2, 0xba, 0x5d, 0xf3, 0xc5, 0xb0, 0xbf, 0xa4, 0x3b, 0x71, 0x44, 0x46, 0x2b, 0xfc, 
		0xeb, 0x6f, 0xd5, 0xf6, 0x14, 0xfe, 0x7c, 0x70, 0x5a, 0x7d, 0xfd, 0x2f, 0x18, 0x83, 0x16, 0xa5, 
		0x91, 0x1f, 0x05, 0x95, 0x74, 0xa9, 0xc1, 0x5b, 0x4a, 0x85, 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45, 
		0xb2, 0x0f, 0xc9, 0x1c, 0xa6, 0xbc, 0xec, 0x73, 0x90, 0x7b, 0xcf, 0x59, 0x8f, 0xa1, 0xf9, 0x2d, 
		0xf2, 0xb1, 0x00, 0x94, 0x37, 0x9f, 0xd0, 0x2e, 0x9c, 0x6e, 0x28, 0x3f, 0x80, 0xf0, 0x3d, 0xd3, 
		0x25, 0x8a, 0xb5, 0xe7, 0x42, 0xb3, 0xc7, 0xea, 0xf7, 0x4c, 0x11, 0x33, 0x03, 0xa2, 0xac, 0x60
	};
	protected static final short[] SBOX1 = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	};
	protected static final short[] SBOX2 = {
		0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b, 0xd1, 
		0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19, 0x59, 0xc1, 
		0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63, 0xdf, 0xe7, 0xbb, 
		0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa, 0x0f, 0xee, 0x10, 0xeb, 
		0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8, 0x95, 0xf9, 0x2f, 0xce, 0xcd, 
		0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb, 0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53, 
		0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1, 
		0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40, 
		0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84, 0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc, 
		0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3, 0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5, 
		0x15, 0xdd, 0xfd, 0x17, 0xa9, 0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43, 
		0xa7, 0xe1, 0xd0, 0xf5, 0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8, 
		0x30, 0xc6, 0x51, 0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda, 
		0xe6, 0x75, 0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c, 
		0x90, 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d, 
		0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5, 0x81
	};
	protected static final short[][] DIFFUSE_MAPPINGS = {
		{ 3,  4,  6,  8,  9, 13, 14}, { 2,  5,  7,  8,  9, 12, 15}, 
		{ 1,  4,  6, 10, 11, 12, 15}, { 0,  5,  7, 10, 11, 13, 14},
		{ 0,  2,  5,  8, 11, 14, 15}, { 1,  3,  4,  9, 10, 14, 15}, 
		{ 0,  2,  7,  9, 10, 12, 13}, { 1,  3,  6,  8, 11, 12, 13}, 
		{ 0,  1,  4,  7, 10, 13, 15}, { 0,  1,  5,  6, 11, 12, 14}, 
		{ 2,  3,  5,  6,  8, 13, 15}, { 2,  3,  4,  7,  9, 12, 14}, 
		{ 1,  2,  6,  7,  9, 11, 12}, { 0,  3,  6,  7,  8, 10, 13}, 
		{ 0,  3,  4,  5,  9, 11, 14}, { 1,  2,  4,  5,  8, 10, 15}
	};
	
	protected long[][] encryptionKeys;
	
	protected ARIA() {
		super();
		stateSize = NUM_BYTES_IN_STATE;
	}
	
	public boolean canInvertKeySchedule() {
		return false;
	}
	
	public ByteArray computeExpandedKey(ByteArray keyPart, int round) {
		return expandKey(keyPart);
	}
	
	/**
	 * Returns the secret key from the expanded key array.
	 */
	public ByteArray computeKeyPart(ByteArray expandedKey, int round) {
		return expandedKey.splice(0, keySize);
	}
	
	public ByteArray decryptRounds(ByteArray block, int fromRound, int toRound) {
		state = block.clone();
		ByteArray key;
		
		for (int round = fromRound; round <= toRound; round++) {
			key = getRoundKey(round);
			state = decryptRound(state, key, round);
		}
		
		return state;
	}

	public ByteArray encryptRounds(ByteArray block, int fromRound, int toRound) {
		state = block.clone();
		ByteArray key;
		
		for (int round = fromRound; round <= toRound; round++) {
			key = getRoundKey(round);
			state = encryptRound(state, key, round);
		}
		
		return state;
	}
	
	public int getNumActiveComponentsInKeySchedule() {
		// There are three calls to the round function in the key schedule
		return 3 * stateSize;
	}
	
	public ByteArray getRoundKey(int round) {
		int from = (round + 1) * stateSize;
		int to = (round + 2) * stateSize;
		return secretKey.splice(from, to);
	}
	
	public boolean hasKeyInjectionInRound(int round) {
		return round >= 1 && round <= numRounds + 1;
	}
	
	public boolean injectsKeyAtRoundBegin(int round) {
		return true;
	}
	
	public void setKey(ByteArray key) {
		secretKey = expandKey(key);
	}
	
	public void setExpandedKey(ByteArray expandedKey) {
		secretKey = expandedKey.clone();
	}
	
	public ByteArray evenKeyExpansionFunction(ByteArray word, ByteArray key) {
		return encryptRound(word, key, 2);
	}
	
	public ByteArray oddKeyExpansionFunction(ByteArray word, ByteArray key) {
		return encryptRound(word, key, 1);
	}
	
	protected ByteArray diffuse(ByteArray state) {
		ByteArray newState = new ByteArray(NUM_BYTES_IN_STATE);
		
		for (int i = 0; i < NUM_BYTES_IN_STATE; i++) {
			short value = 0;
			
			for (int j = 0; j < DIFFUSE_MAPPINGS[i].length; j++) {
				value ^= state.get(DIFFUSE_MAPPINGS[i][j]);
			}
			
			newState.set(i, value);
		}
		
		return newState;
	}
	
	protected long[] diffuse(long[] state) {
		ByteArray array = new ByteArray(state);
		return diffuse(array).readLongs();
	}
	
	protected ByteArray invertDiffuse(ByteArray state) {
		return diffuse(state);
	}

	protected long[] invertDiffuse(long[] state) {
		return diffuse(state);
	}
	
	protected ByteArray decryptRound(ByteArray state, ByteArray key, int round) {
		if (round == numRounds) {
			state = addRoundKey(numRounds + 1, state);
		} else {
			state = invertDiffuse(state);
		}
		
		state = invertSubstitute(state, round);
		state.xor(key);
		return state;
	}
	
	protected ByteArray encryptRound(ByteArray state, ByteArray key, int round) {
		state.xor(key);
		state = substitute(state, round);
		
		if (round == numRounds) {
			state = addRoundKey(numRounds + 1, state);
		} else {
			state = diffuse(state);
		}
		
		return state;
	}
	
	protected ByteArray expandKey(ByteArray key) {
		long[] keywords = key.readLongs();
		long[] kl = new long[2];
		long[] kr = new long[2];
		long[][] w = new long[4][2]; // 4 x 128-bit words w0, w1, w2, w3
		
		for (int i = 0; i < keywords.length; i++) {
			if (i < 2) {
				kl[i] = keywords[i];
			} else {
				kr[i - 2] = keywords[i];
			}
		}
		
		w[0] = kl;
		w[1] = oddKeyExpansionFunction(w[0], keyExpansionConstant1, kr);
		w[2] = evenKeyExpansionFunction(w[1], keyExpansionConstant2, w[0]);
		w[3] = oddKeyExpansionFunction(w[2], keyExpansionConstant3, w[1]);
		
		encryptionKeys = new long[19][2];
		encryptionKeys[0] = kl;
		encryptionKeys[1] = kr;
		
		encryptionKeys[2] = xor(w[0], rotateRight(w[1], 19));
		encryptionKeys[3] = xor(w[1], rotateRight(w[2], 19));
		encryptionKeys[4] = xor(w[2], rotateRight(w[3], 19));
		encryptionKeys[5] = xor(rotateRight(w[0], 19), w[3]);
		
		encryptionKeys[6] = xor(w[0], rotateRight(w[1], 31));
		encryptionKeys[7] = xor(w[1], rotateRight(w[2], 31));
		encryptionKeys[8] = xor(w[2], rotateRight(w[3], 31));
		encryptionKeys[9] = xor(rotateRight(w[0], 31), w[3]);
		
		encryptionKeys[10] = xor(w[0], rotateLeft(w[1], 61));
		encryptionKeys[11] = xor(w[1], rotateLeft(w[2], 61));
		encryptionKeys[12] = xor(w[2], rotateLeft(w[3], 61));
		encryptionKeys[13] = xor(rotateLeft(w[0], 61), w[3]);
		
		encryptionKeys[14] = xor(w[0], rotateLeft(w[1], 31));
		encryptionKeys[15] = xor(w[1], rotateLeft(w[2], 31));
		encryptionKeys[16] = xor(w[2], rotateLeft(w[3], 31));
		encryptionKeys[17] = xor(rotateLeft(w[0], 31), w[3]);
		
		encryptionKeys[18] = xor(w[0], rotateLeft(w[1], 19));
		return new ByteArray(encryptionKeys);
	}
	
	protected long[] evenKeyExpansionFunction(long[] word, long[] key, long[] xorResultWith) {
		long[] roundResult = encryptRound(new ByteArray(word), new ByteArray(key), 2).readLongs();
		return xor(roundResult, xorResultWith);
	}
	
	protected long[] oddKeyExpansionFunction(long[] word, long[] key, long[] xorResultWith) {
		long[] roundResult = encryptRound(new ByteArray(word), new ByteArray(key), 1).readLongs();
		return xor(roundResult, xorResultWith);
	}
	
	protected ByteArray invertSubstitute(ByteArray state, int round) {
		boolean isOddRound = (round >= 0) && (round % 2) == 1;
		
		if (isOddRound) {
			return substituteEven(state);
		} else {
			return substituteOdd(state);
		}
	}
	
	protected ByteArray substitute(ByteArray state, int round) {
		boolean isOddRound = (round >= 0) && (round % 2) == 1;
		
		if (isOddRound) {
			return substituteOdd(state);
		} else {
			return substituteEven(state);
		}
	}
	
	protected ByteArray substituteEven(ByteArray state) { 
		int index = 0;
		
		for (int i = 0; i < NUM_COLUMNS_IN_STATE; i++) {
			state.set(index, INVERSE_SBOX1[state.get(index)]);
			index++;
			state.set(index, INVERSE_SBOX2[state.get(index)]);
			index++;
			state.set(index, SBOX1[state.get(index)]);
			index++;
			state.set(index, SBOX2[state.get(index)]);
			index++;
		}
		
		return state;
	}
	
	protected ByteArray substituteOdd(ByteArray state) { 
		int index = 0;
		
		for (int i = 0; i < NUM_COLUMNS_IN_STATE; i++) {
			state.set(index, SBOX1[state.get(index)]);
			index++;
			state.set(index, SBOX2[state.get(index)]);
			index++;
			state.set(index, INVERSE_SBOX1[state.get(index)]);
			index++;
			state.set(index, INVERSE_SBOX2[state.get(index)]);
			index++;
		}
		
		return state;
	}
	
	protected long[] xor(long[] left, long[] right) {
		long[] result = new long[2];
		
		for (int i = 0; i < left.length; i++) {
			result[i] = left[i] ^ right[i];
		}
		
		return result;
	}
	
	protected long[] rotateLeft(long[] value, int rotation) {
		long[] result = new long[2];
		
		long msbMask = getMSBMask(64 - rotation); 	// 11...11000
		long lsbMask = getLSBMask(rotation);		// 00...00111
		
		result[0] = (Long.rotateLeft(value[0], rotation) & msbMask)
			| (Long.rotateLeft(value[1], rotation) & lsbMask);
		result[1] = (Long.rotateLeft(value[1], rotation) & msbMask)
			| (Long.rotateLeft(value[0], rotation) & lsbMask);
		
		return result;
	}
	
	protected long[] rotateRight(long[] value, int rotation) {
		long[] result = new long[2];
		long msbMask = getMSBMask(rotation); 		// 11...11000
		long lsbMask = getLSBMask(64 - rotation);	// 00...00111
		
		result[0] = (Long.rotateRight(value[0], rotation) & lsbMask)
			| (Long.rotateRight(value[1], rotation) & msbMask);
		result[1] = (Long.rotateRight(value[1], rotation) & lsbMask)
			| (Long.rotateRight(value[0], rotation) & msbMask);
		
		
		return result;
	}
	
	private long getLSBMask(int numBits) {
		long mask = 0L;
		
		for (int i = 0; i < numBits; i++) {
			if (i < 31) {
				mask |= 1 << i;	
			} else {
				mask |= (long)(1 << (i - 31)) << 31;
			}
		}
		
		return mask;
	}
	
	private long getMSBMask(int numBits) {
		long mask = 0L;
		
		for (int i = 0; i < numBits; i++) {
			if (i <= 31) {
				mask |= (long)(1 << (31 - i)) << 32;	
			} else {
				mask |= (long)(1 << (63 - i));
			}
		}
		
		return mask;
	}
	
}
