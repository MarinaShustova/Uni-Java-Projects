package de.mslab.ciphers;

import static org.junit.Assert.assertTrue;

import java.util.Arrays;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import de.mslab.core.ByteArray;

public class LBlockTest extends AbstractCipherTest {
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		cipher = new LBlock();
	}
	
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		cipher = null;
	}
	
	@Test
	public void testDecrypt() {
		int[] key = { 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc };
		int[] plaintext = { 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef };
		int[] ciphertext = { 0x4b,0x71,0x79,0xd8,0xeb,0xee,0x0c,0x26 };
		testDecryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testDecryptEmptyValues() {
		int[] key = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] plaintext = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] ciphertext = { 0xc2,0x18,0x18,0x53,0x08,0xe7,0x5b,0xcd };
		testDecryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testEncrypt() {
		int[] key = { 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc };
		int[] plaintext = { 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef };
		int[] ciphertext = { 0x4b,0x71,0x79,0xd8,0xeb,0xee,0x0c,0x26 };
		testEncryption(key, plaintext, ciphertext);
		logger.info(cipher.getExpandedKey());
	}
	
	@Test
	public void testEncryptEmptyValues() {
		int[] key = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] plaintext = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] ciphertext = { 0xc2,0x18,0x18,0x53,0x08,0xe7,0x5b,0xcd };
		testEncryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testKeyExpansion() {
		int[] fullKeyRegisterStates = {
			0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0x67,0x35,0x79,0xbd,0xbf,0xdb,
			0x80,0x24,0x68,0xac,0xc6,0xfb,0x70,0x04,0x0d,0x15,0x8c,0xe6,0xaf,0x37,0x47,0xa2,
			0xb1,0x9c,0x15,0xe6,0xf8,0xdf,0x6e,0x00,0x4e,0xbc,0xdf,0x1a,0xed,0xc0,0x08,0xf4,
			0x56,0x33,0x24,0xb8,0x01,0x1f,0xca,0xc6,0x69,0xd7,0x9b,0xe3,0x6c,0x58,0xcd,0x3b,
			0x73,0x7c,0x64,0x97,0x00,0x23,0x91,0x6f,0x8c,0x93,0x20,0x04,0x6d,0x8b,0x19,0xa7,
			0x9f,0x00,0x8d,0xb3,0x63,0x34,0xf2,0x2d,0xf1,0x92,0x92,0x66,0x9e,0x47,0xfe,0x32,
			0x53,0xe0,0x11,0xb6,0x63,0xc6,0x4a,0x7e,0x82,0x36,0xd2,0x4c,0xd3,0xc8,0xa8,0x46,
			0xda,0x4b,0x5a,0x79,0x0c,0x78,0xc9,0x4f,0x9a,0x4f,0x21,0x8c,0x19,0x29,0xf5,0x08,
			0xdb,0x49,0x45,0x25,0x3e,0xa2,0x5b,0x69,0x33,0x49,0xe4,0x31,0x7a,0x6d,0x26,0x6a,
			0xbc,0x86,0x28,0xa4,0xa7,0xd4,0x26,0x90,0xc5,0x17,0x54,0xfa,0x8f,0x4d,0xa4,0xcd,
			0x39,0x9f,0x51,0xed,0xb4,0x99,0xa4,0xd2,0x18,0xa2,0xc0,0x93,0x34,0x9e,0x03,0x14,
			0x47,0x33,0xea,0x3d,0xe8,0x62,0x88,0xe2,0xfd,0x47,0xb8,0x12,0x66,0x93,0x23,0xa8,
			0xf7,0x06,0x8c,0xd2,0x7d,0x0c,0x51,0x1c,0xa7,0x9a,0x4f,0xa4,0x8a,0x23,0x84,0x75,
			0x1e,0xe0,0x87,0x44,0x70,0x8b,0xe3,0xdc,0x14,0xf3,0x49,0xf4,0xd2,0x7b,0x82,0x9b,
			0xe9,0x3e,0x90,0xe8,0x8e,0x11,0xd4,0x27,0xd2,0x18,0xd1,0xc2,0x3a,0x4f,0x70,0x53,
			0x59,0x38,0x47,0x4f,0xee,0x0a,0x7a,0x84,0xfa,0x43,0x64,0xc1,0x4f,0x56,0xdf,0x48,
			0x6b,0x27,0x08,0xe9,0xaa,0xe9,0x0d,0x62,0x61,0x1d,0x2c,0x98,0x29,0xea,0x72,0x23,
			0xa5,0x95,0xc5,0x3d,0x55,0x5d,0x21,0xac,0xcb,0xa7,0xaa,0xac,0xa4,0x35,0x8e,0x44,
			0x74,0xb2,0x8f,0x86,0xb1,0xcf,0xce,0x96,0x59,0x74,0xf5,0x55,0x6c,0xd2,0xcb,0x29,
			0x1e,0xaa,0xb1,0xf0,0xd6,0x39,0xf5,0xd5,0x56,0x39,0xda,0xc7,0x2d,0x9a,0x59,0x65
		};
		ByteArray secretKey = new ByteArray(fullKeyRegisterStates);
		ByteArray keyPart;
		ByteArray computedExpandedKey;
		int from, to;
		int[] registerState;
		
		for (int roundIndex = 1; roundIndex <= cipher.getNumRounds(); roundIndex++) {
			from = (roundIndex - 1) * cipher.getKeySize();
			to = roundIndex * cipher.getKeySize();
			registerState = Arrays.copyOfRange(fullKeyRegisterStates, from, to);
			keyPart = new ByteArray(registerState);
			computedExpandedKey = cipher.computeExpandedKey(keyPart, roundIndex);
			//logger.info("round {0} part {1} key \n{2}", roundIndex, keyPart, computedExpandedKey);
			assertTrue(secretKey.equals(computedExpandedKey));
		}
	}
	
}
