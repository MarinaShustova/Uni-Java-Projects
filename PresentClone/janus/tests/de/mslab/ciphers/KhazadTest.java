package de.mslab.ciphers;

import java.util.Arrays;

import static org.junit.Assert.*;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import de.mslab.core.ByteArray;

public class KhazadTest extends AbstractCipherTest {
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		cipher = new Khazad();
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		cipher = null;
	}
	
	@Test
	public final void testDecryptRounds() {
		int[] keyArray = { 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		int[] plaintextArray = { 0, 0, 0, 0, 0, 0, 0, 0 };
		int[] ciphertextArray = { 0x49, 0xA4, 0xCE, 0x32, 0xAC, 0x19, 0x0E, 0x3F };
		testDecryption(keyArray, plaintextArray, ciphertextArray);
	}
	
	@Test
	public final void testDecryptRounds2() {
		int[] keyArray = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 };
		int[] plaintextArray = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 };
		int[] ciphertextArray = { 0x3D, 0x66, 0x6F, 0x99, 0x12, 0x62, 0xFD, 0x70 };
		testDecryption(keyArray, plaintextArray, ciphertextArray);
	}
	
	@Test
	public final void testEncryptRounds() {
		int[] keyArray = { 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		int[] plaintextArray = { 0, 0, 0, 0, 0, 0, 0, 0 };
		int[] ciphertextArray = { 0x49, 0xA4, 0xCE, 0x32, 0xAC, 0x19, 0x0E, 0x3F };
		testEncryption(keyArray, plaintextArray, ciphertextArray);
	}
	
	@Test
	public final void testEncryptRounds2() {
		int[] keyArray = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 };
		int[] plaintextArray = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 };
		int[] ciphertextArray = { 0x3D, 0x66, 0x6F, 0x99, 0x12, 0x62, 0xFD, 0x70 };
		testEncryption(keyArray, plaintextArray, ciphertextArray);
	}
	
	@Test
	public void testExpandKey() {
		int[] roundKeys;
		int[] expandedKeyShouldBe = { 
			0xef,0x01,0x7a,0x21,0x06,0x86,0x87,0x18,0x82,0xa5,0x7a,0x34,0xde,0x3e,0x03,0x05,
			0x7a,0xe6,0x41,0x0b,0xcc,0xdc,0xa0,0x6d,0xc6,0x82,0x79,0xf4,0xba,0xac,0xf2,0x5b,
			0x1c,0x6b,0xbd,0xfe,0xf7,0x41,0xcc,0x47,0xed,0x66,0x65,0xf9,0x74,0x16,0x4a,0x4a,
			0x0b,0xe0,0xf9,0xb7,0x37,0x61,0x14,0x7b,0x82,0x7c,0xd7,0x36,0x60,0x25,0x1c,0xde,
			0xe9,0xf4,0x52,0xd1,0xf9,0x7c,0x0a,0xcd
		};
		ByteArray secretKey = new ByteArray(expandedKeyShouldBe);
		ByteArray keyPart;
		ByteArray computedExpandedKey;
		int stateSize = cipher.getStateSize();
		int from, to;
		
		for (int roundIndex = 0; roundIndex < cipher.getNumRounds(); roundIndex++) {
			from = roundIndex * stateSize;
			to = (roundIndex + 2) * stateSize;
			roundKeys = Arrays.copyOfRange(expandedKeyShouldBe, from, to);
			keyPart = new ByteArray(roundKeys);
			computedExpandedKey = cipher.computeExpandedKey(keyPart, roundIndex);
			
			assertTrue(secretKey.equals(computedExpandedKey));
		}
	}
	
}
