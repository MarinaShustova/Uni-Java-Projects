package de.mslab.ciphers;

import static org.junit.Assert.assertTrue;

import java.util.Arrays;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import de.mslab.core.ByteArray;

public class KLEIN64Test extends AbstractCipherTest {
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		cipher = new KLEIN64();
	}
	
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		cipher = null;
	}
	
	@Test
	public void testMix() {
		ByteArray state = new ByteArray(new int[]{ 0xF1,0xFF,0xFF,0xAA,0xAA,0xFF,0xFF,0xFF, 0,0,0,0, 0,0,0,0 });
		AES aes = new AES128();
		ByteArray output = aes.mixColumns(state);
		logger.info("test mix {0}", output);
	}
	
	@Test
	public void testDecrypt() {
		int[] key = { 0x12,0x34,0x56,0x78,0x90,0xAB,0xCD,0xEF };
		int[] plaintext = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF };
		int[] ciphertext = { 0x59,0x23,0x56,0xC4,0x99,0x71,0x76,0xC8 };
		testDecryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testDecryptEmptyKey() {
		int[] key = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] plaintext = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF };
		int[] ciphertext = { 0xCD,0xC0,0xB5,0x1F,0x14,0x72,0x2B,0xBE };
		testDecryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testDecryptEmptyMessage() {
		int[] key = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF };
		int[] plaintext = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] ciphertext = { 0x64,0x56,0x76,0x4E,0x86,0x02,0xE1,0x54 };
		testDecryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testEncrypt() {
		int[] key = { 0x12,0x34,0x56,0x78,0x90,0xAB,0xCD,0xEF };
		int[] plaintext = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF };
		int[] ciphertext = { 0x59,0x23,0x56,0xC4,0x99,0x71,0x76,0xC8 };
		testEncryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testEncryptEmptyKey() {
		int[] key = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] plaintext = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF };
		int[] ciphertext = { 0xCD,0xC0,0xB5,0x1F,0x14,0x72,0x2B,0xBE };
		testEncryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testEncryptEmptyMessage() {
		int[] key = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF };
		int[] plaintext = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
		int[] ciphertext = { 0x64,0x56,0x76,0x4E,0x86,0x02,0xE1,0x54 };
		testEncryption(key, plaintext, ciphertext);
	}
	
	@Test
	public void testExpandKey() { 
		int[] fullKeyRegisterStates = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x01,0x00,0x00,0x77,0x77,0x00,
			0x77,0x77,0x02,0x00,0x77,0x0b,0x77,0x00, 0x0b,0x77,0x03,0x77,0x7c,0x0f,0x77,0x00,
			0x0f,0x77,0x04,0x7c,0x78,0x01,0x00,0x77, 0x01,0x00,0x72,0x78,0x76,0x71,0x76,0x77,
			0x71,0x76,0x71,0x76,0x71,0x71,0x75,0x77, 0x71,0x75,0x70,0x71,0x07,0x71,0x74,0x00,
			0x71,0x74,0x08,0x07,0x04,0x71,0x04,0x76, 0x71,0x04,0x7f,0x04,0x05,0x78,0x04,0x75,
			0x78,0x04,0x7f,0x05,0x7c,0x06,0x04,0x74, 0x06,0x04,0x7f,0x7c,0x02,0x06,0x04,0x04,
			0x06,0x04,0x08,0x02,0x02,0x06,0x0c,0x04
		};
		ByteArray secretKey = new ByteArray(fullKeyRegisterStates);
		ByteArray keyPart;
		ByteArray computedExpandedKey;
		int from, to;
		int[] registerState;
		
		for (int roundIndex = 1; roundIndex <= cipher.getNumRounds(); roundIndex++) {
			from = (roundIndex - 1) * cipher.getKeySize();
			to = roundIndex * cipher.getKeySize();
			registerState = Arrays.copyOfRange(fullKeyRegisterStates, from, to);
			keyPart = new ByteArray(registerState);
			computedExpandedKey = cipher.computeExpandedKey(keyPart, roundIndex);
			// logger.info("round {0} part {1} key \n{2}", roundIndex, keyPart, computedExpandedKey);
			assertTrue(secretKey.equals(computedExpandedKey));
		}
	}
	
	@Test
	public void testEncryptionSpeed() {
		long numIterations = 1000000;
		ByteArray block = new ByteArray(8);
		cipher.setKey(block);
		long start = System.nanoTime();
		
		for (int i = 0; i < numIterations; i++) {
			block = cipher.encrypt(block);
		}
		
		long end = System.nanoTime();
		double time = ((double)(end - start) / 1000.0) / (double)numIterations;
		logger.info("time per 1,000,000 encryptions: {0}s", time);
	}
	
}
